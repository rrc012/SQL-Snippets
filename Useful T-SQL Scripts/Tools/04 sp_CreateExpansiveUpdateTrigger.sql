USE [master]
--This script contains code at the end of the script to convert the new stored procedure into a system stored procedure.
GO
 CREATE PROCEDURE [dbo].[sp_CreateExpansiveUpdateTrigger]
/**********************************************************************************************************************
 Purpose:
 Creates or replaces a trigger on the target table that measures the expansion of variable width columns to assist with
 determining what can be done to alleviate the Logical and Physical Fragmentation the such "ExpAnsive UPDATEs" cause
 on indexes, particularly but not limited to Clustered Indexes.

 The trigger compares the minimum length of each upated variable width column in the DELETED logical trigger table to 
 the maximum length for of that same column in the INSERTED logical trigger table.  Only those variable width columns
 that have suffered an UPDATE (even if the data has not been made to change) will be recorded in the 
 "dbo.DBA_ExpansiveUpdateLog" table.

 Note that although every effort has been made to "cause no harm", the author of this code is not responsible for any
 usage of this code nor is responsible for the suitability of the code for any appliction or usage nor is responsible
 for any damage caused either directly or indirectly.  Any revisions to the code may or may not not be propagated by
 the author. The code and all code and objects that it generates are offered "as is".
-----------------------------------------------------------------------------------------------------------------------
 Example Usage:
   EXEC sp_CreateExpansiveUpdateTrigger 'SchemaNameHere.TableNameHere'
;
 Note:
 1. Follow up by using the sp_AnalyzeExpansiveUpdates stored procedure to help analyze the data collected after the
    collection triggers have been running at least a day or two.  Results will be more accurate if you collect the
    data for a week or so because more things will have had their way with the tables that are being collected from
    by the triggers.
-----------------------------------------------------------------------------------------------------------------------
 Programmer Notes:
 1. This code is easiest to use when it lives in the master database as a "system stored procedure".  That allows it
    to be used from any database just by calling it from the database where the target table lives.

    If you do create the stored procedure in the master database, then make the stored procedure a "system" stored
    procedure by executing the following code:

    USE MASTER;  
--===== Reclassify the stored procedure as a system stored procedure.
   EXEC sp_ms_marksystemobject 'sp_CreateExpansiveUpdateTrigger'
;  
--===== If the following code returns a 1 for "is_ms_shipped", then it worked.
 SELECT name, is_ms_shipped   
   FROM sys.objects  
  WHERE name = 'sp_CreateExpansiveUpdateTrigger'  
;
 2. The trigger that is created will automatically create the "dbo.DBA_ExpansiveUpdateLog" table in the current
    database if it does not exist.  This not only makes the trigger easier to deploy but it also prevents the trigger
    from failing on possibly critical tables if someone deleted the "dbo.DBA_ExpansiveUpdateLog" table prior to
    deleting all triggers that write data to that table.

    You can easily find the tables that "still" have such triggers by running the following code in the database 
    where you want to find all such triggers.

 SELECT * FROM sys.triggers WHERE name LIKE 'ExpansiveUpdate%';

 3. This code has only been tested on "Row Store" tables and is not recommended for use on other types of tables.

 4. To make changes to the "dbo.DBA_ExpansiveUpdateLog" table, you must do it in the code below that generates the
    table if it doesn't exist.  The same holds true for the triggers that are generated by this code. The must not
    be modified directly.  All changes should be made through this code.

 5. As with all triggers, there is additional operational overhead and duration of execution of the code that caused
    the trigger to fire.  While these triggers only check for and measure those variable width columns that have
    suffered an UPDATE, there could be a substantial delay for large batches of updates especially if those updates
    affect a great number of variable width columns.  In testing, a million row update of 2 columns took about 
    10 seconds longer with the trigger in place than the 16 seconds it took without the trigger.

 6. The column names in the "dbo.DBA_ExpansiveUpdateLog" are mostly self documenting. The following explains those that
    are not:

    ExpansiveUpdateLogID
    --------------------
    Just a sequential row number to guarantee the uniqueness of each row.

    IsExpansive
    -----------
    If the MaxNewLen > MinOldLen, this will be a "1", indicating that there was an increase (expansion) in the length
    of the data somewhere in any of the rows affected. This can be the cause of both Logical and Physical Fragmentation
    (Page Density decrease).

    If the MaxNewLen < MinOldLen, this will be a "-1", indicating that there was an decrease "contraction" in the length
    of the data somewhere in any of the rows affected. This can be the cause of Physical Fragmentation (Page Density
    decrease).

    If the MaxNewLen = MinOldLen, this will be a "0", indicating that there was no change in length and that no Logical
    or Physical fragmentation occurred as a result of datalength changes. Note that there could still be fragmentation 
    caused in the Clustered and non-clustered due to other reasons, especially if the index key column(s) changed in
    value even if the length of data did not change.

    UpdateCnt
    ---------
    The total number of rows affected by the UPDATE for this batch.

 7. Every attempt has been made to keep this code compatible with all versions of SQL Server from 2005 onward. However,
    the code has only been tested in SQL Server 2008 and 2016 and no guarantees are made that the code won't need some
    form of modification, particularly for SQL Server 2005.
-----------------------------------------------------------------------------------------------------------------------
 Revision History:
 Rev 00 - 19 Jan 2019 - Jeff Moden
        - Conversion and unit test of "Proof-of-Principle" code to fully documented code.
**********************************************************************************************************************/
--===== Parameters for this proc
        @pFullTableName    NVARCHAR(300) --Must be a two part table name (SchemaName.TableName) of an existing table.
     AS
--=====================================================================================================================
--      Local Variables
--=====================================================================================================================
DECLARE  @ColumnTemplate    NVARCHAR(MAX)
        ,@ExpansiveColumns  NVARCHAR(MAX)
        ,@PKColumns         NVARCHAR(MAX)
        ,@SchemaName        SYSNAME
        ,@SQL               NVARCHAR(MAX) 
        ,@TableName         SYSNAME
        ,@TableObjectID     NVARCHAR(10)
        ,@Today             NCHAR(11)
;
--=====================================================================================================================
--      Validate the Schema and Table names of the @pFullTableName parameter.
--      This also prevents and SQL Injection attempts.
--=====================================================================================================================
--===== Validate that the full table name exists as a table
 SELECT @TableObjectID = CONVERT(NVARCHAR(10),OBJECT_ID(@pFullTableName,'U'))
;
     IF NULLIF(@TableObjectID,'') IS NULL
  BEGIN
        RAISERROR('The "%s" tablename does not exist in the current database. Run ABORTED.',11,1,@pFullTableName);
        RETURN --1
    END
;
--===== Split the 2 part table name into SchemaName and TableName so that we can manipulate the names separately
     -- using dynamic SQL.
 SELECT  @SchemaName = PARSENAME(@pFullTableName,2)
        ,@TableName  = PARSENAME(@pFullTableName,1)
;
--===== Validate the table name has 2 parts (SchemaName and TableName)
     IF @SchemaName IS NULL
  BEGIN
        RAISERROR('The "%s" tablename does not list a schema name. Run ABORTED.',11,2,@pFullTableName);
        RETURN --2
    END
;
--=====================================================================================================================
--      Create the SQL to create the trigger.
--      We use the object_id of the table instead of the name so that we don't have to deal with wierd names that
--      have spaces, dashes, and other improper characters.
--      If you have such characters in the schema name, it should still work that's crazy, IMHO. ;-)
--=====================================================================================================================
--===== If the trigger already exists, drop it so we can rebuild it.
 SELECT @SQL =  REPLACE(REPLACE(N'
     IF OBJECT_ID(''<<@SchemaName>>.ExpansiveUpdate_<<@TableObjectID>>'') IS NOT NULL
   DROP TRIGGER <<@SchemaName>>.ExpansiveUpdate_<<@TableObjectID>>;'
                ,'<<@SchemaName>>'   ,@SchemaName)
                ,'<<@TableObjectID>>',@TableObjectID)
;
   EXEC (@SQL)
;
--===== Create the CREATE TRIGGER statement
 SELECT  @Today = CONVERT(NCHAR(11),GETDATE(),106)
        ,@SQL = N'
 CREATE TRIGGER ' + @SchemaName + '.ExpansiveUpdate_' + @TableObjectID + '\
 ON ' + @pFullTableName + ' AFTER UPDATE AS
/**********************************************************************************************************************
 Purpose:
 Collect information about "ExpAnsive" Updates of variable width columns from the table this trigger lives on.

 See the comments in the sp_CreateExpansiveUpdateTrigger for details.
 Do NOT modify this trigger directly. See the "Programmer Notes" below.

 Programmer Notes:
 1. This trigger is automatically created/replaced by the sp_CreateExpansiveUpdateTrigger stored procedure.
 2. The trigger collects information in a common table called "dbo.DBA_ExpansiveUpdateLog" within the current database.
    If you need to change that table name or make any modifications to what the table containd, do it in the stored
    procedure rather than in this trigger code.  The stored procedure is designed to automatically create the
    "dbo.DBA_ExpansiveUpdateLog" in each trigger if it doesn''t exist to keep this type of trigger from failing if
    someone deletes the table before all such "ExpansiveUpdate" triggers are dropped.
 3. The numeric value in the trigger name is the object_id of the underlying table.

 Revision History:
 Rev 00 - '+@Today+ ' - Automatically created by the sp_CreateExpansiveUpdateTrigger stored procedure.
                      - DO NOT MODIFY THIS TRIGGER CODE DIRECTLY!
**********************************************************************************************************************/
--=====================================================================================================================
--      Presets
--=====================================================================================================================
--===== Prevent rowcount returns which may be interpreted as errors
    SET NOCOUNT ON
;
--===== Remember the current date and time
DECLARE @SampleDT DATETIME;
 SELECT @SampleDT = GETDATE()
;'
;
--===== Create the section of code that guarantees that the "expansive update log" table exists.
 SELECT @SQL = @SQL + N'
--=====================================================================================================================
--      Ensure that the log table exists so the trigger doesn''t fail
--=====================================================================================================================
--===== If it doesn''t exist, create the log table.
     IF OBJECT_ID(''dbo.DBA_ExpansiveUpdateLog'',''U'') IS NULL 
 CREATE TABLE dbo.DBA_ExpansiveUpdateLog
        (
         ExpansiveUpdateLogID   BIGINT IDENTITY(1,1)
        ,SampleDT               DATETIME
        ,TableFullName          SYSNAME
        ,ColumnName             SYSNAME
        ,MinOldLen              BIGINT
        ,MaxNewLen              BIGINT
        ,IsExpansive            SMALLINT
        ,UpdateCnt              BIGINT
        )  
;
--=====================================================================================================================
--      Log each variable width column that has been updated
--=====================================================================================================================
--===== Prevent expected warnings for NULLs for the MIN and MAX length aggregates.
    SET ANSI_WARNINGS OFF
;'
;
--===== Get the Primary Key Columns to join the DELETED and INSERTED logical trigger tables on.
 SELECT @PKColumns  = ISNULL(@PKColumns + ' AND ','') 
                    + REPLACE('i.<<name>> = d.<<name>>','<<name>>',col.name)
   FROM sys.indexes         idx
   JOIN sys.index_columns   idxcol  ON idx.object_id = idxcol.object_id AND idx.index_id  = idxcol.index_id
   JOIN sys.columns         col     ON col.object_id = idxcol.object_id AND col.column_id = idxcol.column_id
  WHERE idx.object_id       = @TableObjectID
    AND idx.is_primary_key  = 1
    AND idx.is_disabled     = 0
    AND idx.is_hypothetical = 0
  ORDER BY key_ordinal
;
--===== Make sure there was a PK.  If not, abort
     IF NULLIF(@PKColumns,N' ') IS NULL
  BEGIN
        RAISERROR('The "%s" tablename does not have a Primary Key. Run ABORTED.',11,3,@pFullTableName);
        RETURN --3
    END
;
--===== Create the code template that will create the code for each variable width column.
 SELECT @ColumnTemplate = REPLACE(N'
     IF UPDATE(<<column_name>>)
 INSERT INTO dbo.DBA_ExpansiveUpdateLog
        (SampleDT, TableFullName, ColumnName, MinOldLen, MaxNewLen, IsExpansive, UpdateCnt)
 SELECT  SampleDT       = @SampleDT
        ,TableFullName  = N<<@pFullTableName>>
        ,ColumnName     = N<<qcolumn_name>>
        ,MinOldLen      = MIN(DATALENGTH(d.<<column_name>>))
        ,MaxNewLen      = MAX(DATALENGTH(i.<<column_name>>))
        ,IsExpansive    = MAX(SIGN(
                              ISNULL(DATALENGTH(i.<<column_name>>),0)
                            - ISNULL(DATALENGTH(d.<<column_name>>),0)
                          ))
        ,UpdateCnt  = COUNT_BIG(*)
   FROM INSERTED    i
   JOIN DELETED     d ON <<@PKColumns>>
;'      ,'<<@PKColumns>>',@PKColumns) 
        + REPLICATE('-',118)
;
--===== Create a section of code for each variable width column to be logged if it is updated (expansively or not)
 SELECT @ExpansiveColumns = ISNULL(@ExpansiveColumns,N'')
                          + REPLACE(REPLACE(REPLACE(
                                @ColumnTemplate
                            ,'<<column_name>>'      ,QUOTENAME(name))
                            ,'<<qcolumn_name>>'     ,QUOTENAME(name,''''))
                            ,'<<@pFullTableName>>'  ,QUOTENAME(@pFullTableName,''''))
   FROM sys.columns
  WHERE object_id = OBJECT_ID(@pFullTableName)
    AND user_type_id IN (34,35,98,99,128,129,130,165,167,231,240,241,243,256)
;
--===== Make sure there were expansive columns.  If not, abort.
     IF NULLIF(@ExpansiveColumns,N' ') IS NULL
  BEGIN
        RAISERROR('The "%s" tablename does not have any potential expansive columnns. Run ABORTED.',11,4,@pFullTableName);
        RETURN --4
    END
;
--===== Add the expansive column code to the trigger.
 SELECT @SQL = @SQL + @ExpansiveColumns
;
--===== Terminate the trigger with a comment just to let people know that we got all the columns.
 SELECT @SQL = @SQL + N'
--=====================================================================================================================
--      End of Trigger.
--=====================================================================================================================
'
--===== Display the full code
 SELECT * FROM util.ShowLongString(@SQL)
;
--===== Execute the code to create the trigger.
   EXEC (@SQL)
;
GO
--=====================================================================================================================
--      Change the stored procedure that we just created into a "System Stored Procedure" so that we can execute it
--      from any "current" database.
--=====================================================================================================================
    USE MASTER;  
--===== Reclassify the stored procedure as a system stored procedure.
   EXEC sp_ms_marksystemobject 'sp_CreateExpansiveUpdateTrigger'
;  
--===== If the following code returns a 1 for "is_ms_shipped", then it worked.
 SELECT name, is_ms_shipped   
   FROM sys.objects  
  WHERE name = 'sp_CreateExpansiveUpdateTrigger'  
;